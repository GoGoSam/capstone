// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robocomms.proto

#ifndef PROTOBUF_robocomms_2eproto__INCLUDED
#define PROTOBUF_robocomms_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace RoboComms {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_robocomms_2eproto();
void protobuf_AssignDesc_robocomms_2eproto();
void protobuf_ShutdownFile_robocomms_2eproto();

class RoboReq;
class RoboReq_MoveBaseCmd;
class RoboReq_MoveLiftCmd;
class RoboReq_MoveSensCmd;
class RoboReq_DataReq;
class RoboRes;
class RoboRes_DataRes;

enum RoboReq_Type {
  RoboReq_Type_MBASE = 0,
  RoboReq_Type_MLIFT = 1,
  RoboReq_Type_MSENS = 2,
  RoboReq_Type_RDATA = 3
};
bool RoboReq_Type_IsValid(int value);
const RoboReq_Type RoboReq_Type_Type_MIN = RoboReq_Type_MBASE;
const RoboReq_Type RoboReq_Type_Type_MAX = RoboReq_Type_RDATA;
const int RoboReq_Type_Type_ARRAYSIZE = RoboReq_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoboReq_Type_descriptor();
inline const ::std::string& RoboReq_Type_Name(RoboReq_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoboReq_Type_descriptor(), value);
}
inline bool RoboReq_Type_Parse(
    const ::std::string& name, RoboReq_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoboReq_Type>(
    RoboReq_Type_descriptor(), name, value);
}
enum RoboRes_Type {
  RoboRes_Type_DATAR = 0
};
bool RoboRes_Type_IsValid(int value);
const RoboRes_Type RoboRes_Type_Type_MIN = RoboRes_Type_DATAR;
const RoboRes_Type RoboRes_Type_Type_MAX = RoboRes_Type_DATAR;
const int RoboRes_Type_Type_ARRAYSIZE = RoboRes_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoboRes_Type_descriptor();
inline const ::std::string& RoboRes_Type_Name(RoboRes_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoboRes_Type_descriptor(), value);
}
inline bool RoboRes_Type_Parse(
    const ::std::string& name, RoboRes_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoboRes_Type>(
    RoboRes_Type_descriptor(), name, value);
}
// ===================================================================

class RoboReq_MoveBaseCmd : public ::google::protobuf::Message {
 public:
  RoboReq_MoveBaseCmd();
  virtual ~RoboReq_MoveBaseCmd();

  RoboReq_MoveBaseCmd(const RoboReq_MoveBaseCmd& from);

  inline RoboReq_MoveBaseCmd& operator=(const RoboReq_MoveBaseCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoboReq_MoveBaseCmd& default_instance();

  void Swap(RoboReq_MoveBaseCmd* other);

  // implements Message ----------------------------------------------

  RoboReq_MoveBaseCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoboReq_MoveBaseCmd& from);
  void MergeFrom(const RoboReq_MoveBaseCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const void* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:RoboComms.RoboReq.MoveBaseCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_robocomms_2eproto();
  friend void protobuf_AssignDesc_robocomms_2eproto();
  friend void protobuf_ShutdownFile_robocomms_2eproto();

  void InitAsDefaultInstance();
  static RoboReq_MoveBaseCmd* default_instance_;
};
// -------------------------------------------------------------------

class RoboReq_MoveLiftCmd : public ::google::protobuf::Message {
 public:
  RoboReq_MoveLiftCmd();
  virtual ~RoboReq_MoveLiftCmd();

  RoboReq_MoveLiftCmd(const RoboReq_MoveLiftCmd& from);

  inline RoboReq_MoveLiftCmd& operator=(const RoboReq_MoveLiftCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoboReq_MoveLiftCmd& default_instance();

  void Swap(RoboReq_MoveLiftCmd* other);

  // implements Message ----------------------------------------------

  RoboReq_MoveLiftCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoboReq_MoveLiftCmd& from);
  void MergeFrom(const RoboReq_MoveLiftCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const void* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:RoboComms.RoboReq.MoveLiftCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_robocomms_2eproto();
  friend void protobuf_AssignDesc_robocomms_2eproto();
  friend void protobuf_ShutdownFile_robocomms_2eproto();

  void InitAsDefaultInstance();
  static RoboReq_MoveLiftCmd* default_instance_;
};
// -------------------------------------------------------------------

class RoboReq_MoveSensCmd : public ::google::protobuf::Message {
 public:
  RoboReq_MoveSensCmd();
  virtual ~RoboReq_MoveSensCmd();

  RoboReq_MoveSensCmd(const RoboReq_MoveSensCmd& from);

  inline RoboReq_MoveSensCmd& operator=(const RoboReq_MoveSensCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoboReq_MoveSensCmd& default_instance();

  void Swap(RoboReq_MoveSensCmd* other);

  // implements Message ----------------------------------------------

  RoboReq_MoveSensCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoboReq_MoveSensCmd& from);
  void MergeFrom(const RoboReq_MoveSensCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:RoboComms.RoboReq.MoveSensCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_robocomms_2eproto();
  friend void protobuf_AssignDesc_robocomms_2eproto();
  friend void protobuf_ShutdownFile_robocomms_2eproto();

  void InitAsDefaultInstance();
  static RoboReq_MoveSensCmd* default_instance_;
};
// -------------------------------------------------------------------

class RoboReq_DataReq : public ::google::protobuf::Message {
 public:
  RoboReq_DataReq();
  virtual ~RoboReq_DataReq();

  RoboReq_DataReq(const RoboReq_DataReq& from);

  inline RoboReq_DataReq& operator=(const RoboReq_DataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoboReq_DataReq& default_instance();

  void Swap(RoboReq_DataReq* other);

  // implements Message ----------------------------------------------

  RoboReq_DataReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoboReq_DataReq& from);
  void MergeFrom(const RoboReq_DataReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:RoboComms.RoboReq.DataReq)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_robocomms_2eproto();
  friend void protobuf_AssignDesc_robocomms_2eproto();
  friend void protobuf_ShutdownFile_robocomms_2eproto();

  void InitAsDefaultInstance();
  static RoboReq_DataReq* default_instance_;
};
// -------------------------------------------------------------------

class RoboReq : public ::google::protobuf::Message {
 public:
  RoboReq();
  virtual ~RoboReq();

  RoboReq(const RoboReq& from);

  inline RoboReq& operator=(const RoboReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoboReq& default_instance();

  void Swap(RoboReq* other);

  // implements Message ----------------------------------------------

  RoboReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoboReq& from);
  void MergeFrom(const RoboReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoboReq_MoveBaseCmd MoveBaseCmd;
  typedef RoboReq_MoveLiftCmd MoveLiftCmd;
  typedef RoboReq_MoveSensCmd MoveSensCmd;
  typedef RoboReq_DataReq DataReq;

  typedef RoboReq_Type Type;
  static const Type MBASE = RoboReq_Type_MBASE;
  static const Type MLIFT = RoboReq_Type_MLIFT;
  static const Type MSENS = RoboReq_Type_MSENS;
  static const Type RDATA = RoboReq_Type_RDATA;
  static inline bool Type_IsValid(int value) {
    return RoboReq_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RoboReq_Type_Type_MIN;
  static const Type Type_MAX =
    RoboReq_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RoboReq_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RoboReq_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RoboReq_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RoboReq_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .RoboComms.RoboReq.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::RoboComms::RoboReq_Type type() const;
  inline void set_type(::RoboComms::RoboReq_Type value);

  // optional .RoboComms.RoboReq.MoveBaseCmd base = 2;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 2;
  inline const ::RoboComms::RoboReq_MoveBaseCmd& base() const;
  inline ::RoboComms::RoboReq_MoveBaseCmd* mutable_base();
  inline ::RoboComms::RoboReq_MoveBaseCmd* release_base();
  inline void set_allocated_base(::RoboComms::RoboReq_MoveBaseCmd* base);

  // optional .RoboComms.RoboReq.MoveLiftCmd lift = 3;
  inline bool has_lift() const;
  inline void clear_lift();
  static const int kLiftFieldNumber = 3;
  inline const ::RoboComms::RoboReq_MoveLiftCmd& lift() const;
  inline ::RoboComms::RoboReq_MoveLiftCmd* mutable_lift();
  inline ::RoboComms::RoboReq_MoveLiftCmd* release_lift();
  inline void set_allocated_lift(::RoboComms::RoboReq_MoveLiftCmd* lift);

  // optional .RoboComms.RoboReq.MoveSensCmd sens = 4;
  inline bool has_sens() const;
  inline void clear_sens();
  static const int kSensFieldNumber = 4;
  inline const ::RoboComms::RoboReq_MoveSensCmd& sens() const;
  inline ::RoboComms::RoboReq_MoveSensCmd* mutable_sens();
  inline ::RoboComms::RoboReq_MoveSensCmd* release_sens();
  inline void set_allocated_sens(::RoboComms::RoboReq_MoveSensCmd* sens);

  // optional .RoboComms.RoboReq.DataReq data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::RoboComms::RoboReq_DataReq& data() const;
  inline ::RoboComms::RoboReq_DataReq* mutable_data();
  inline ::RoboComms::RoboReq_DataReq* release_data();
  inline void set_allocated_data(::RoboComms::RoboReq_DataReq* data);

  // @@protoc_insertion_point(class_scope:RoboComms.RoboReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_lift();
  inline void clear_has_lift();
  inline void set_has_sens();
  inline void clear_has_sens();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RoboComms::RoboReq_MoveBaseCmd* base_;
  ::RoboComms::RoboReq_MoveLiftCmd* lift_;
  ::RoboComms::RoboReq_MoveSensCmd* sens_;
  ::RoboComms::RoboReq_DataReq* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_robocomms_2eproto();
  friend void protobuf_AssignDesc_robocomms_2eproto();
  friend void protobuf_ShutdownFile_robocomms_2eproto();

  void InitAsDefaultInstance();
  static RoboReq* default_instance_;
};
// -------------------------------------------------------------------

class RoboRes_DataRes : public ::google::protobuf::Message {
 public:
  RoboRes_DataRes();
  virtual ~RoboRes_DataRes();

  RoboRes_DataRes(const RoboRes_DataRes& from);

  inline RoboRes_DataRes& operator=(const RoboRes_DataRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoboRes_DataRes& default_instance();

  void Swap(RoboRes_DataRes* other);

  // implements Message ----------------------------------------------

  RoboRes_DataRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoboRes_DataRes& from);
  void MergeFrom(const RoboRes_DataRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string res = 1;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline const ::std::string& res() const;
  inline void set_res(const ::std::string& value);
  inline void set_res(const char* value);
  inline void set_res(const char* value, size_t size);
  inline ::std::string* mutable_res();
  inline ::std::string* release_res();
  inline void set_allocated_res(::std::string* res);

  // @@protoc_insertion_point(class_scope:RoboComms.RoboRes.DataRes)
 private:
  inline void set_has_res();
  inline void clear_has_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_robocomms_2eproto();
  friend void protobuf_AssignDesc_robocomms_2eproto();
  friend void protobuf_ShutdownFile_robocomms_2eproto();

  void InitAsDefaultInstance();
  static RoboRes_DataRes* default_instance_;
};
// -------------------------------------------------------------------

class RoboRes : public ::google::protobuf::Message {
 public:
  RoboRes();
  virtual ~RoboRes();

  RoboRes(const RoboRes& from);

  inline RoboRes& operator=(const RoboRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoboRes& default_instance();

  void Swap(RoboRes* other);

  // implements Message ----------------------------------------------

  RoboRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoboRes& from);
  void MergeFrom(const RoboRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoboRes_DataRes DataRes;

  typedef RoboRes_Type Type;
  static const Type DATAR = RoboRes_Type_DATAR;
  static inline bool Type_IsValid(int value) {
    return RoboRes_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RoboRes_Type_Type_MIN;
  static const Type Type_MAX =
    RoboRes_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RoboRes_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RoboRes_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RoboRes_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RoboRes_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .RoboComms.RoboRes.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::RoboComms::RoboRes_Type type() const;
  inline void set_type(::RoboComms::RoboRes_Type value);

  // optional .RoboComms.RoboRes.DataRes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::RoboComms::RoboRes_DataRes& data() const;
  inline ::RoboComms::RoboRes_DataRes* mutable_data();
  inline ::RoboComms::RoboRes_DataRes* release_data();
  inline void set_allocated_data(::RoboComms::RoboRes_DataRes* data);

  // @@protoc_insertion_point(class_scope:RoboComms.RoboRes)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RoboComms::RoboRes_DataRes* data_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_robocomms_2eproto();
  friend void protobuf_AssignDesc_robocomms_2eproto();
  friend void protobuf_ShutdownFile_robocomms_2eproto();

  void InitAsDefaultInstance();
  static RoboRes* default_instance_;
};
// ===================================================================


// ===================================================================

// RoboReq_MoveBaseCmd

// optional bytes cmd = 1;
inline bool RoboReq_MoveBaseCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoboReq_MoveBaseCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoboReq_MoveBaseCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoboReq_MoveBaseCmd::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& RoboReq_MoveBaseCmd::cmd() const {
  return *cmd_;
}
inline void RoboReq_MoveBaseCmd::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_MoveBaseCmd::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_MoveBaseCmd::set_cmd(const void* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoboReq_MoveBaseCmd::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* RoboReq_MoveBaseCmd::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoboReq_MoveBaseCmd::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoboReq_MoveLiftCmd

// optional bytes cmd = 1;
inline bool RoboReq_MoveLiftCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoboReq_MoveLiftCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoboReq_MoveLiftCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoboReq_MoveLiftCmd::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& RoboReq_MoveLiftCmd::cmd() const {
  return *cmd_;
}
inline void RoboReq_MoveLiftCmd::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_MoveLiftCmd::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_MoveLiftCmd::set_cmd(const void* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoboReq_MoveLiftCmd::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* RoboReq_MoveLiftCmd::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoboReq_MoveLiftCmd::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoboReq_MoveSensCmd

// optional string cmd = 1;
inline bool RoboReq_MoveSensCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoboReq_MoveSensCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoboReq_MoveSensCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoboReq_MoveSensCmd::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& RoboReq_MoveSensCmd::cmd() const {
  return *cmd_;
}
inline void RoboReq_MoveSensCmd::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_MoveSensCmd::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_MoveSensCmd::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoboReq_MoveSensCmd::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* RoboReq_MoveSensCmd::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoboReq_MoveSensCmd::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoboReq_DataReq

// optional string cmd = 1;
inline bool RoboReq_DataReq::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoboReq_DataReq::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoboReq_DataReq::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoboReq_DataReq::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& RoboReq_DataReq::cmd() const {
  return *cmd_;
}
inline void RoboReq_DataReq::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_DataReq::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
}
inline void RoboReq_DataReq::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoboReq_DataReq::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    cmd_ = new ::std::string;
  }
  return cmd_;
}
inline ::std::string* RoboReq_DataReq::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoboReq_DataReq::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::kEmptyString) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoboReq

// required .RoboComms.RoboReq.Type type = 1;
inline bool RoboReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoboReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoboReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoboReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::RoboComms::RoboReq_Type RoboReq::type() const {
  return static_cast< ::RoboComms::RoboReq_Type >(type_);
}
inline void RoboReq::set_type(::RoboComms::RoboReq_Type value) {
  assert(::RoboComms::RoboReq_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .RoboComms.RoboReq.MoveBaseCmd base = 2;
inline bool RoboReq::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoboReq::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoboReq::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoboReq::clear_base() {
  if (base_ != NULL) base_->::RoboComms::RoboReq_MoveBaseCmd::Clear();
  clear_has_base();
}
inline const ::RoboComms::RoboReq_MoveBaseCmd& RoboReq::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::RoboComms::RoboReq_MoveBaseCmd* RoboReq::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::RoboComms::RoboReq_MoveBaseCmd;
  return base_;
}
inline ::RoboComms::RoboReq_MoveBaseCmd* RoboReq::release_base() {
  clear_has_base();
  ::RoboComms::RoboReq_MoveBaseCmd* temp = base_;
  base_ = NULL;
  return temp;
}
inline void RoboReq::set_allocated_base(::RoboComms::RoboReq_MoveBaseCmd* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .RoboComms.RoboReq.MoveLiftCmd lift = 3;
inline bool RoboReq::has_lift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoboReq::set_has_lift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoboReq::clear_has_lift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoboReq::clear_lift() {
  if (lift_ != NULL) lift_->::RoboComms::RoboReq_MoveLiftCmd::Clear();
  clear_has_lift();
}
inline const ::RoboComms::RoboReq_MoveLiftCmd& RoboReq::lift() const {
  return lift_ != NULL ? *lift_ : *default_instance_->lift_;
}
inline ::RoboComms::RoboReq_MoveLiftCmd* RoboReq::mutable_lift() {
  set_has_lift();
  if (lift_ == NULL) lift_ = new ::RoboComms::RoboReq_MoveLiftCmd;
  return lift_;
}
inline ::RoboComms::RoboReq_MoveLiftCmd* RoboReq::release_lift() {
  clear_has_lift();
  ::RoboComms::RoboReq_MoveLiftCmd* temp = lift_;
  lift_ = NULL;
  return temp;
}
inline void RoboReq::set_allocated_lift(::RoboComms::RoboReq_MoveLiftCmd* lift) {
  delete lift_;
  lift_ = lift;
  if (lift) {
    set_has_lift();
  } else {
    clear_has_lift();
  }
}

// optional .RoboComms.RoboReq.MoveSensCmd sens = 4;
inline bool RoboReq::has_sens() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoboReq::set_has_sens() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoboReq::clear_has_sens() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoboReq::clear_sens() {
  if (sens_ != NULL) sens_->::RoboComms::RoboReq_MoveSensCmd::Clear();
  clear_has_sens();
}
inline const ::RoboComms::RoboReq_MoveSensCmd& RoboReq::sens() const {
  return sens_ != NULL ? *sens_ : *default_instance_->sens_;
}
inline ::RoboComms::RoboReq_MoveSensCmd* RoboReq::mutable_sens() {
  set_has_sens();
  if (sens_ == NULL) sens_ = new ::RoboComms::RoboReq_MoveSensCmd;
  return sens_;
}
inline ::RoboComms::RoboReq_MoveSensCmd* RoboReq::release_sens() {
  clear_has_sens();
  ::RoboComms::RoboReq_MoveSensCmd* temp = sens_;
  sens_ = NULL;
  return temp;
}
inline void RoboReq::set_allocated_sens(::RoboComms::RoboReq_MoveSensCmd* sens) {
  delete sens_;
  sens_ = sens;
  if (sens) {
    set_has_sens();
  } else {
    clear_has_sens();
  }
}

// optional .RoboComms.RoboReq.DataReq data = 5;
inline bool RoboReq::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoboReq::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoboReq::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoboReq::clear_data() {
  if (data_ != NULL) data_->::RoboComms::RoboReq_DataReq::Clear();
  clear_has_data();
}
inline const ::RoboComms::RoboReq_DataReq& RoboReq::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::RoboComms::RoboReq_DataReq* RoboReq::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::RoboComms::RoboReq_DataReq;
  return data_;
}
inline ::RoboComms::RoboReq_DataReq* RoboReq::release_data() {
  clear_has_data();
  ::RoboComms::RoboReq_DataReq* temp = data_;
  data_ = NULL;
  return temp;
}
inline void RoboReq::set_allocated_data(::RoboComms::RoboReq_DataReq* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// RoboRes_DataRes

// optional string res = 1;
inline bool RoboRes_DataRes::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoboRes_DataRes::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoboRes_DataRes::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoboRes_DataRes::clear_res() {
  if (res_ != &::google::protobuf::internal::kEmptyString) {
    res_->clear();
  }
  clear_has_res();
}
inline const ::std::string& RoboRes_DataRes::res() const {
  return *res_;
}
inline void RoboRes_DataRes::set_res(const ::std::string& value) {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  res_->assign(value);
}
inline void RoboRes_DataRes::set_res(const char* value) {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  res_->assign(value);
}
inline void RoboRes_DataRes::set_res(const char* value, size_t size) {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  res_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoboRes_DataRes::mutable_res() {
  set_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    res_ = new ::std::string;
  }
  return res_;
}
inline ::std::string* RoboRes_DataRes::release_res() {
  clear_has_res();
  if (res_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = res_;
    res_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoboRes_DataRes::set_allocated_res(::std::string* res) {
  if (res_ != &::google::protobuf::internal::kEmptyString) {
    delete res_;
  }
  if (res) {
    set_has_res();
    res_ = res;
  } else {
    clear_has_res();
    res_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoboRes

// required .RoboComms.RoboRes.Type type = 1;
inline bool RoboRes::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoboRes::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoboRes::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoboRes::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::RoboComms::RoboRes_Type RoboRes::type() const {
  return static_cast< ::RoboComms::RoboRes_Type >(type_);
}
inline void RoboRes::set_type(::RoboComms::RoboRes_Type value) {
  assert(::RoboComms::RoboRes_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .RoboComms.RoboRes.DataRes data = 2;
inline bool RoboRes::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoboRes::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoboRes::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoboRes::clear_data() {
  if (data_ != NULL) data_->::RoboComms::RoboRes_DataRes::Clear();
  clear_has_data();
}
inline const ::RoboComms::RoboRes_DataRes& RoboRes::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::RoboComms::RoboRes_DataRes* RoboRes::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::RoboComms::RoboRes_DataRes;
  return data_;
}
inline ::RoboComms::RoboRes_DataRes* RoboRes::release_data() {
  clear_has_data();
  ::RoboComms::RoboRes_DataRes* temp = data_;
  data_ = NULL;
  return temp;
}
inline void RoboRes::set_allocated_data(::RoboComms::RoboRes_DataRes* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RoboComms

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoboComms::RoboReq_Type>() {
  return ::RoboComms::RoboReq_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoboComms::RoboRes_Type>() {
  return ::RoboComms::RoboRes_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_robocomms_2eproto__INCLUDED
